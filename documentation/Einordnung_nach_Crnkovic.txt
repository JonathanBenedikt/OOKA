Unsere Komponentenmodell erfüllt nach Crnkovic folgende Bereiche:
Lifecycle:
	- Implementation, durch das vorschreiben der Programmiersprache Java und der @Start und @Stop Methode
	- Packaging, durch das wir auf Bytecode im JAR-Format bestehen.
	- Deployment, at run-time da wir die Komponenten dynamisch einbinden und rauswerfen können.

Construction: 
	- Interface Specification:
		- Operational Interface: Da wir Java Interface Classes benutzen
		- Trennung von Requested/Provided (?)
		- Direkt in Programming Language (Java) Definiert.
		- Bin mir nicht sicher ob Bytecode, als das selbe wie MS COM gilt
			- Static semantic level: Java hat starke typisierung
			- Functional Semantic level: Nur begrenzt durch die Limits der Datentypen
			- behavior level: gegeben durch unsere States.
	- Binding
		- Aktuell ist Horizontal binding nicht möglich ebensowenig wie vertical binding. Aber im Rahmen von Microservices wäre Horizontal sinnvoller. 
		- Aktuell ebenfalls nicht implementiert, allerdings wäre es sinnvoll exogenous binding zu 			verwenden, um eine Trennung der Verantwortlichkeite zu gewährleisten.
	- Communication Style: 
		- ähnlich wie Binding noch nicht spezifiziert
		- Communication Style: aktuell nur synchron möglich
		- Interaction Style: aktive Components, starten einmal und laufen dann selbständig in Thread.
